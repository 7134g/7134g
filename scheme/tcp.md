# TCP协议, 从入门到放弃
## 引言
> 尽管TCP和UDP都使用相同的网络层(IP)，TCP却向应用层提供与UDP完全不同的服务。TCP提供一种面向连接的、可靠的字节流服务。
面向连接意味着两个使用TCP的应用(通常是一个客户和一个服务器)在彼此交换数据之前必须先建立一个TCP连接。

```
这一过程与打电话很相似，先拨号振铃，等待对方摘机说“喂”，然后才说明是谁
```

* 应用数据被分割成TCP认为最适合发送的数据块。
* 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
* 当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒
* TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段(希望发端超时并重发)。
* 既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。
* 既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据。
* TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。

```
QA:上述提到的端到端的TCP首部检验和会被路由器修改吗? 生存时间TTL会被修改吗?
```

**TCP数据在IP数据报中封装**

![](../img/tcp/tcp-head.png)

```text
源端口（Source Port）：这是源主机使用的端口号。
目标端口（Destination Port）：这是目标主机使用的端口号。
序列号（Sequence Number）：用来标识报文段的顺序，以便接收端按正确的顺序组装数据。
确认号（Acknowledgment Number）：用来确认收到的数据的数量，同时表明下一次期望收到的数据的序列号。
数据偏移（Data Offset）：指示 TCP 头部的长度，以 32 位字为单位。这个字段的最小值是 5，表示 TCP 头部的长度为 20 字节。
保留位（Reserved）：暂时没有使用，必须设置为 0。
控制位（Flags）：共有 9 个标志位，包括 URG、ACK、PSH、RST、SYN、FIN 和三个保留位。控制位用来表示 TCP 报文段的状态和功能。
窗口大小（Window Size）：指定发送方所能接收的字节数量。这个数值是动态变化的，可以根据网络情况进行调整。
校验和（Checksum）：用来验证数据的完整性，保证数据在传输过程中没有被修改或损坏。
紧急指针（Urgent Pointer）：如果 URG 标志被设置为 1，那么这个字段表示紧急数据的末尾位置。
选项（Options）：可选的 TCP 选项，比如 MSS、窗口缩放因子等。
填充（Padding）：如果 TCP 头部的长度不是 32 位的整数倍，则用填充字段将其补齐。填充字段可以是任意值。


最常用的标志位是 SYN、ACK 和 FIN。
SYN（Synchronize Sequence Numbers）：表示建立一个新连接。在三次握手过程中，客户端发送 SYN=1 的报文段给服务端，服务端收到后回复 ACK+SYN=1 的报文段，表示连接已经建立。
ACK（Acknowledgment）：表示确认序号。在 TCP 连接建立之后，每个传输的数据报都需要被确认，接收方使用 ACK 标志表示确认已经收到的数据。ACK 报文段的确认号字段指示下一个希望收到的字节序号。
FIN（Finish）：表示终止一个连接。发送方发送 FIN=1 的报文段后，等待对方的确认。接收方收到 FIN 后，如果还有未收到的数据，则先将这些数据接收完毕后再发送 ACK 确认报文段，然后发送 FIN=1 的报文段给发送方，等待发送方的确认。
除了上述标志位之外，TCP 还支持 PSH（Push）、RST（Reset）和 URG（Urgent）标志。

PSH（Push）：表示尽快将缓存区中的数据发送出去，而不是等待缓存区满了再发送。
RST（Reset）：表示重置一个连接。当一个错误发生时，可以使用 RST 消息将连接重置，清除所有的未完成操作。
URG（Urgent）：表示紧急数据，用于发送一些优先级较高的数据。如果 URG 标志被设置，紧急指针字段就被用来标识紧急数据的末尾位置。
```



## TCP连接的建立与终止

### TCP拥塞控制算法
```text
TCP拥塞控制算法是保证网络传输可靠性和公平性的重要机制之一。
它的目标是当网络中出现拥塞时，避免发送方继续增加数据流量，从而导致更多的数据包丢失或延迟，进而恶化网络拥堵情况。
常用的TCP拥塞控制算法包括慢启动、拥塞避免、快重传和快恢复等。
```

```text
慢启动算法是在TCP连接建立时进行的，它通过逐渐增加发送窗口大小来确定网络的带宽容量，并在网络出现拥塞时减少窗口大小以进行拥塞控制。
拥塞避免算法则是在慢启动之后进行的，它通过线性增加发送窗口大小来避免网络拥塞，同时检测是否发生了拥塞并对其进行响应。
```

```text
快重传和快恢复算法则是为了加速数据包传输而设计的。
如果接收方连续收到相同序号的数据包，就可以认为前一个数据包可能已经丢失，
这时就可以立即发送一个ACK确认数据包，从而跳过等待超时（RTO）的过程，实现快速重传。
而快恢复算法则是在发生拥塞时，当接收到3个相同序号的ACK确认数据包时，增加拥塞窗口大小来恢复发送速度。
```

### 连接建立与终止
![](../img/tcp/tcp_hend1.png)

#### 连接终止协议
![](../img/tcp/tcp_fin.png)

```
建立一个连接需要三次握手，而终止一个连接要经过4次握手。这由TCP的半关闭
(half-close)造成的。既然一个TCP连接是全双工(即数据在两个方向上能同
时传递)，因此每个方向必须单独地进行关闭。这原则就是当一方完成它的数据
发送任务后就能发送一个FIN来终止这个方向连接。当一端收到一个FIN，它必
须通知应用层另一端几经终止了那个方向的数据传送。发送FIN通常是应用层进
行关闭的结果。
```
- QA: 当服务器发出FIN的ack后,客户端发送数据给服务端,服务端如何回应?
- A: 服务器将会忽略这些数据


### 连接建立的超时
![](../img/tcp/tcp_retry.png)

```
传输层（即 TCP 层）提供可靠的传输，然而，TCP 层依赖的链路本身是不可
靠的，TCP 是如何在不可靠的环境中提供可靠服务的呢？
答案是超时和重传。

TCP 在发送数据时设置一个定时器，当定时器溢出还没有收到 ACK，则重传该数据。因此，超时与重传的关键之处在于如何决定定时器间隔与重传频率。

传统 Unix 实现中，定时器的间隔取决于数据的往返时间（即 RTT），根据 RTT 进行一定的计算得到重传超时间隔（即 RTO）。
由于网络路由、流量等的变化，RTT 是经常发生变化的，

RTT 的测量也极为复杂（平滑算法、Karn 算法、Jacbson 算法等）重传的时间间隔，取整后分别为1、3、6、12、24、48和多个64秒。
这个倍乘的关系被称为“指数退避”。

从上图可以发现， 客户端发起了 SYN 包后，一直没有收到服务端的 ACK ，所以一直超时重传了 5 次，并且每次 RTO 超时时间是不同的：

第一次是在 1 秒超时重传
第二次是在 3 秒超时重传
第三次是在 7 秒超时重传
第四次是在 15 秒超时重传
第五次是在 31 秒超时重传
可以发现，每次超时时间 RTO 是指数（翻倍）上涨的，当超过最大重传次数后，客户端不再发送 SYN 包。

```

连接超时重传间隔策略:

* Linux与Android: 指数递增(1,2,4,8,16)
* OPPO:(0.25,0.5,1,2,4,8,16,32,64,64,64…)
* SamSung:(0.42,0.9,1.8,3.7,7.5,15,30,60,120,120…)
* iOS: 优化后的指数递增(1,1,1,1,1,2,4,8,16)


### 复位报文段
```
复位报文段（Reset Segment）是一种用于终止TCP连接的控制报文
TCP头部中的RST标志位被设置为1以表示该数据包是一个复位报文段
复位报文段通常用于终止连接或指示连接出现错误。当TCP接收到一个复位报文段时，它将立即关闭连接，并释放所有相关的资源。

例如当一个套接字已经被关闭但仍然存在未处理的数据时，可以发送复位报文段来强制清除缓存并终止连接。
复位报文段则是一种异常情况下的手动断开连接的方式，它会直接终止连接，并允许发送端和接收端跳过正常的连接终止握手过程。

QA: 当一个数据报到达目的端口时,该端口没在使用
TCP则使用复位 / UDP:ICMP端口不可达的信息
```

### QA同时打开/关闭?

## 交互数据流
### 引言
```
如果按照分组数量计算，约有一半的TCP报文段包含成块数据(如FTP、电子邮件和RSS新闻)，另一半则包含交互数据(如Telnet和Rlogin)。

如果按字节计算，则成块数据与交互数据的比例约为90%和10%。这是因为成块数据的报文段基本上都是满长度(full-sized)的(通常为512字节的用户数据)，

而交互数据则小得多(上述研究表明Telnet和Rlogin分组中通常约90%左右的用户数据小于10个字节)。

很明显，TCP需要同时处理这两类数据，但使用的处理算法则有所不同。
```
### 交互式数据
![](../img/tcp/tcp_rlogin.png)

```
第一行客户发送字符d到服务器，第二行服务器发送该字符的回显和确认，第三行客户发送该字符回显的确认。

对于\n字符，客户只发送了一个字符，但服务器的回显是两个字符，分别是回车\r和换行\n，\r可用CR表示，\n可用LF表示。

第十六行是来自服务器的date命令的输出，这30个字符由28字符的date命令输出和2字节的CR/LF组成。

第十八行是服务器发往客户的7个字符，这是服务器主机上的客户提示符svr4 % （百分号后边有个空格）。
```
### 延迟确认
![](../img/tcp/tcp_rlogin1.webp)

```
通常TCP在接收到数据时并不立即发送ACK;相反，它推迟发送，以便将ACK与需要沿该方向发送的数据一起发送(有时称这种现象为数据捎带ACK)。
绝大多数实现采用的时延为200ms，也就是说，TCP将以最大200ms的时延等待是否有数据一起发送。
不论TCP何时设置一个定时器，该定时器都可能在将来1~200ms和1~500ms的任一处内核溢出。

因此挥手时候会可能会看到只用了三次挥手
```

### Nagle算法
> 在一个Rlogin连接上客户一般每次发送一个字节到服务器，这就产生了一些41字节长的分组:20字节的IP首部、20字节的TCP首部和1个字节的数据。在局域网上，这些小分组(被称为微小分组(tinygram))通常不会引起麻烦，因为局域网一般不会出现拥塞。但在广域网上，这些小分组则会增加拥塞出现的可能。一种简单和好的方法就是采用
RFC896[Nagle1984]中所建议的Nagle算法。

> 该算法要求一个TCP连接上最多只能有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送其他的小分组。相反，TCP收集这些少量的分组，并在确认到来时以一个分组的方式发出去。该算法的优越之处在于它是自适应的:确认到达得越快，数据也就发送得越快。而在希望减少微小分组数目的低速广域网上，则会发送更少的分组.

![](../img/tcp/tcp_nagle.webp)

```
其次，注意到从左到右待发数据的长度是不同的，分别为:1、1、2、1、2、2、
3、1和3个字节。这是因为客户只有收到前一个数据的确认后才发送已经收集的
数据。通过使用Nagle算法，为发送16个字节的数据客户只需要使用9个报文
段，而不再是16个
```

```
报文段14和15看起来似乎是与Nagle算法相违背的，但我们需要通过检查序号来
观察其中的真相。因为确认序号是54，因此报文段14是报文段12中确认的应
答。但客户在发送该报文段之前，接收到了来自服务器的报文段13，报文段15中
包含了对序号为56的报文段13的确认。因此即使我们看到从客户到服务器有两个
连续返回的报文段，客户也是遵守了Nagle算法的。
```
```
经受时延的ACK，但该ACK是从服务器到客户的(报文段12)，因为它不包含任何
数据，因此我们可以假定这是经受时延的ACK。服务器当时一定非常忙，因此无
法在服务器的定时器溢出前及时处理所收到的字符。
```

### 窗口大小通告
> 报文段5通告的窗口大小为4095个字节，这意味着在TCP的缓冲区中仍然有一个字节等待应用程序(Rlogin客户)读取。同样，来自客户的下一个报文段声明其窗口大小为4094个字节，这说明仍有两个字节等待读取。

> TCP(报文段18)确认仅仅表明TCP已经正确接收了数据。最后一个报文段的窗口大小为8189而非8192，表明服务器进程尚未读取这三个收到的数据。

## 成块的数据流
### 正常的数据流
![]()

```
三个报文段4、5和6依次到达并按接收顺序放到IP的输入队列。IP将按同样顺序
将它们交给TCP。当TCP处理报文段4时，该连接被标记为产生一个经受时延的确
认。TCP处理下一报文段(5)，由于TCP现在有两个未完成的报文段需要确认，
因此产生一个序号为2048的ACK(报文段7)，并清除该连接产生经受时延的确认
标志。TCP处理下一个报文段(6)，而连接又被标志为产生一个经受时延的确
认。在报文段9到来之前，由于时延定时器溢出，因此产生一个序号为3073的
ACK(报文段8)。报文段8中的窗口大小为3072，表明在TCP的接收缓存中还有
1024个字节的数据等待被应用程序读取。
```
===
**从一个快的发送方到一个慢的接收方**
![]()

```
发送方发送4个背靠背(back-to-back)的数据报文段去填充接收方的窗口，然后停下来等待一个ACK。接收方发送ACK(报文段8)，
但通告其窗口大小为0，这说明接收方已收到所有数据，但这些数据都在接收方的TCP缓冲区，因为应用程序还没有机会读取这些数据。
另一个ACK(称为窗口更新)在17.4ms后发送，表明接收方现在可以接收另外的4096个字节的数据。
虽然这看起来像一个ACK，但由于它并不确认任何新数据，只是用来增加窗口的右边沿，因此被称为窗口更新。
```

### 滑动窗口
**TCP滑动窗口可视化表示**

![]()

> 当接收方确认数据后，这个滑动窗口不时地向右移动。窗口两个边沿的相对运动增加或 减少了窗口的大小。

![]()

> 我们使用三个术语来描述窗口左右边沿的运动:
1) 称窗口左边沿向右边沿靠近为窗口合拢。这种现象发生在数据被发送和确认时。
2) 当窗口右边沿向右移动时将允许发送更多的数据，我们称之为窗口张开。这种现象发 生在另一端的接收进程读取已经确认的数据并释放了TCP的接收缓存时。
3) 当右边沿向左移动时，我们称之为窗口收缩。 Host Requirements RFC强烈建议不要使 用这种方式。

```
如果左边沿到达右边沿，则称其为一个零窗口，此时发送方不能够发送任何数据。
```

####小结与QA
![]()
![]()

```
1) 发送方不必发送一个全窗口大小的数据。
2) 来自接收方的一个报文段确认数据并把窗口向右边滑动。这是因为窗口的大小是相对
3) 正如从报文段7到报文段8中变化的那样，窗口的大小可以减小，但是窗口的右边沿却不能够向左移动。
4) 接收方在发送一个ACK前不必等待窗口被填满。在前面我们看到许多实现每收到两个报文段就会发送一个ACK。
```
### 慢启动

```
迄今为止，在本章所有的例子中，发送方一开始便向网络发送多个报文段，直至达到接 收方通告的窗口大小为止。当发送方和接收方处于同一个局域网时，这种方式是可以的。
但是如果在发送方和接收方之间存在多个路由器和速率较慢的链路时，就有可能出现一些问题。 一些中间路由器必须缓存分组，并有可能耗尽存储器的空间。
```

> TCP需要支持一种被称为“慢启动(slowstart)”的算法。该算法通过观察到新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作。

> 慢启动也叫做指数增长期。慢启动是指每次TCP接收窗口收到确认时都会增长。增加的大小就是已确认段的数目。这种情况一直保持到要么没有收到一些段，要么窗口大小到达预先定义的阈值。

> 慢启动为发送方的TCP增加了另一个窗口:拥塞窗口(congestionwindow)，记为cwnd。

```
当与另一个网络的主机建立TCP连接时，拥塞窗口被初始化为1个报文段(即另一端通告的报文段大小)。每收到一个ACK，
拥塞窗口就增加一个报文段(cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加)。
发送方取拥塞窗口与通告窗口中的最小值作为发送上限。
```
> 拥塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。
### 吞吐量
![]()

```
在时间0，发送方发送了一个报文段。由于发送方处于慢启动中(其拥塞窗口为1个报文段)，因此在继续发送以前它必须等待该数据段的确认。
在时间1,2和3，报文段从左向右移动一个时间单元。在时间4接收方读取这个报文段并产生确认。经过时间5、6和7，ACK移动到左边的发送方。
我们有了一个8个时间单元的往返时间RTT(Round-TripTime)。
```

> 通常发送一个分组的时间取决于两个因素:传播时延(由光的有限速率、传输设备的等待时间等引起)和一个取决于媒体速率(即媒体每秒可传输的比特数)的发送时延。

![]()

```
2个ACK的到达使得拥塞窗口从2个报文段增加为4个，而这4个报文段在时间16~19时被发送。第1个ACK在时间23到达。
4个ACK的到达使得拥塞窗口从4个报文段增加为8个，并在时间24~31发送8个报文段。
```
```
在时间31及其后续时间，发送方和接收方之间的管道(pipe)被填满。此时不论拥塞窗口和通告窗口是多少，它都不能再容纳更多的数据。
每当接收方在某一个时间单位从网络上移去一个报文段，发送方就再发送一个报文段到网络上。但是不管有多少报文段填充了这个管道，
返回路径上总是具有相同数目的ACK。这就是连接的理想稳定状态
```

#### 拥塞

*当数据到达一个大的管道(如一个快速局域网)并向一个较小的管道(如一个较慢的广域网)发送时便会发生拥塞。当多个输入流到达一个路由器，而路由器的输出流小于这些输 入流的总和时也会发生拥塞。*

![]()

```
假定发送方不使用慢启动，它按照局域网的带宽尽可能快地发送编号为1~20的报文段(假定接收方的通告窗口至少为20个报文段)。正如我们看到的那样，ACK之间的间隔与在最慢链路上的一致。假定瓶颈路由器具有足够的容纳这20个分组的缓存。如果这个不能保证，就会引起路由器丢弃分组。
```

## 超时与重传
### 引言
对每个连接，TCP管理4个不同的定时器。

* 重传定时器使用于当希望收到另一端的确认。在本章我们将详细讨论这个定时器以及一些相关的问题，如拥塞避免。
* 坚持(persist)定时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口。
* 保活(keepalive)定时器可检测到一个空闲连接的另一端何时崩溃或重启。
* 2MSL定时器测量一个连接处于TIME_WAIT状态的时间。

### 超时与重传
![]()

```
第1、2和3行表示正常的TCP连接建立的过程，第4行是“hello,world”(12个字符加上回车和换行)的传输过程，第5行是其确认。
第6行表示“and hi”将被发送。第7~18行是这个报文段的12次重传过程，而第19行则是发送方的TCP最
终放弃并发送一个复位信号的过程。
```
> 检查连续重传之间不同的时间差，它们取整后分别为1、3、6、12、24、48和多个64秒。

### 往返时间RTT的测量
TCP超时与重传中最重要的部分就是对一个给定连接的往返时间(RTT)的测量。由于路由器和网络流量均会变化，因此我们认为这个时间可能经常会发生变化，TCP应该跟踪这些变化并相应地改变其超时时间。

![]()


**数据报文段和ACK之间通常并没有一一对应的关系.**

> 每次进行新测量的时候，这个被平滑的RTT将得到更新。每个新估计的90%来自前一个估计，而10%则取自新的测量。

> 在往返时间变化起伏很大时，基于均值和方差来计算RTO，将比作为均值的常数倍数来计算RTO能提供更好的响应。

> 计算RTO的公式依赖于被平滑的RTT和被平滑的均值偏差

####Karn算法
```
在一个分组重传时会产生这样一个问题:假定一个分组被发送。当超时发生时，RTO正进行退避，分组以更长的RTO进行重传，然后收到一个确认。
那么这个ACK是针对第一个分组的还是针对第二个分组呢?这就是所谓的重传多义性问题。
```

> 规定，当一个超时和重传发生时，在重传数据的确认最后到达之前，不能更新RTT估计器，因为我们并不知道ACK对应哪次传输(也许第一次传输被延迟而并没有被丢弃，也有可能第一次传输的ACK被延迟)。
并且，由于数据被重传，RTO已经得到了一个指数退避，我们在下一次传输时使用这个退避后的RTO。对一个没有被重传的报文段而言，除非收到了一个确认，否则不要计算新的RTO。

### 拥塞避免算法

> 慢启动算法是在一个连接上发起数据流的方法，但有时我们会达到中间路由器的极限，此时分组将被丢弃。拥塞避免算法是一种处理丢失分组的方法。
>
> 拥塞避免算法和慢启动算法是两个目的不同、独立的算法。但是当拥塞发生时，我们希望降低分组进入网络的传输速率，于是可以调用慢启动来作到这一点。在实际中这两个算法 通常在一起实现。
>
> 拥塞避免算法和慢启动算法需要对每个连接维持两个变量:一个拥塞窗口cwnd和一个慢启动门限ssthresh 。

![]()

```
在该图中，假定当cwnd为32个报文段时就会发生拥塞。于是设置ssthresh为16个报文段，而cwnd为1个报文段。
在时刻0发送了一个报文段，并假定在时刻1接收到它的ACK，此时cwnd增加为2。接着发送了2个报文段，并假定在时刻2接收到它们的ACK，于是cwnd增加为4(对每个ACK增加1次)。
这种指数增加算法一直进行到在时刻3和4之间收到8个ACK后cwnd等于ssthresh时才停止，
从该时刻起，cwnd以线性方式增加，在每个往返时间内最多增加1个报文段。
```
### 快速重传与快速恢复算法

> 由于我们不知道一个重复的ACK是由一个丢失的报文段引起的，还是由于仅仅出现了几个报文段的重新排序，因此我们等待少量重复的ACK到来。假如这只是一些报文段的重新排序，则在重新排序的报文段被处理并产生一个新的ACK之前，只可能产生1~2个重复的ACK。如果一连串收到3个或3个以上的重复ACK，就非常可能是一个报文段丢失了。

> 于是我们就重传丢失的数据报文段，而无需等待超时定时器溢出。这就是快速重传算法。接下来执行的不是慢启动算法而是拥塞避免算法。这就是快速恢复算法。

![]()

```
在图中可以看到在收到3个重复的ACK之后没有执行慢启动。相反，发送方进行重传，接着在收到重传的ACK以前，发送了3个新的数据的报文段(报文段67,69和71)。
在这种情况下没有执行慢启动的原因是由于收到重复的ACK不仅仅告诉我们一个分组丢失了。由于接收方只有在收到另一个报文段时才会产生重复的ACK，而该报文段已经离开了网络并进入了接收方的缓存。
也就是说，在收发两端之间仍然有流动的数据，而我们不想执行慢启动来突然减少数据流。
```
### ICMP的差错
```
QA:ICMP工作在OSI七层模型哪一层?
```

TCP能够遇到的最常见的ICMP差错就是源站抑制、主机不可达和网络不可达:

* ~~一个接收到的源站抑制引起拥塞窗口cwnd被置为1个报文段大小来发起慢启动，但是慢启动门限ssthresh没有变化，所以窗口将打开直至它或者开放了所有的通路(受窗口大小和往返时间的限制)或者发生了拥塞。~~
* 一个接收到的主机不可达或网络不可达实际上都被忽略，因为这两个差错都被认为是短暂现象。(这有可能是由于中间路由器被关闭而导致选路协议要花费数分钟才能稳定到另一个替换路由)。在这个过程中就可能发生这两个ICMP差错中的一个，`但是连接并不必被关闭`。相反，TCP试图发送引起该差错的数据，尽管最终有可能会超时。如果连接超时，ICMP差错被转换为一个更合适的的差错码 `而不是连接超时`。

![]()

### 重新分组
> 当TCP超时并重传时，它不一定要重传同样的报文段。相反，TCP允许进行重新分组而发送一个较大的报文段，这将有助于提高性能(当然，这个较大的报文段不能够超过接收方声明的MSS)

![]()
![]()

### 小结
* TCP计算往返时间并使用这些测量结果来维护一个被平滑的RTT估计器和被平滑的均值偏差估计器。这两个估计器用来计算下一个重传时间。

* Karn算法在分组丢失时可以不测量RTT就能解决重传的二义性问题。

* TCP多种算法:慢启动、拥塞避免、快速重传和快速恢复。

* 多种ICMP差错对TCP连接的影响以及TCP怎样允许对数据进行重新分组来

## 坚持定时器(persist timer)
![]()

```
如果一个确认丢失了，则双方就有可能因为等待对方而使连接终止:接收方等待接收数 据(因为它已经向发送方通告了一个非0的窗口)，而发送方在等待允许它继续发送数据的窗 口更新。
```

![]()

> 为什么这些间隔总是比5、6、12、24、48和60小一个零点几秒呢?因为这些探查被TCP的500ms定时器超时例程所触发。
>
> 计算坚持定时器时使用了普通的TCP指数退避。但是坚持定时器总是在5~60秒之间。
>
> 坚持状态与重传超时之间一个不同的特点就是TCP从不放弃发送窗口探查。这些探查每隔60秒发送一次，这个过程将持续到或者窗口被打开，或者应用进程使用的连接被终止。

## 保活定时器
### 引言
> 如果TCP连接的双方都没有向对方发送数据，则在两个TCP模块之间不交换任何信息。
没有可以在其他网络协议中发现的轮询。这意味着我们可以启动一个客户与服务器建立一个连接，然后离去数小时、数天、数个星期或者数月，而连接依然保持。中间路由器可以崩溃和重启，电话线可以被挂断再连通，但是只要两端的主机没有被重启，则连接依然保持建立。

> 这意味着两个应用进程—客户进程或服务器进程—都没有使用`应用级的定时器来检测非活动状态，`而这种非活动状态可以导致应用进程中的任何一个终止其活动。

*保活并不是TCP规范中的一部分。3个不使用保活定时器的理由:*

* 在出现短暂差错的情况下，这可能会使一个非常好的连接释放掉;
* 它们耗费不必要的带宽;
* 在按分组计费的情况下会在互联网上花掉更多的钱。 然而，许多实现提供了保活定时器。

### 保活

> 1)客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常工作的。服务器在两小时以后将保活定时器复位。如果在两个小时定时器到时间之前有应用程序的通信量通过此连接，则定时器在交换数据后的未来2小时再复位。

> 2)客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务器将不能够收到对探查的响应，并在75秒后超时。服务器总共发送10个这样的探查，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。

> 3)客户主机崩溃并已经重新启动。这时服务器将收到一个对其保活探查的响应，但是这个响应是一个复位，使得服务器终止这个连接。

> 4)客户主机正常运行，但是从服务器不可达。这与状态2相同，因为TCP不能够区分状态4与状态2之间的区别，它所能发现的就是没有收到探查的响应。

#### 另一端崩溃
![]()

![]()

```
客户在第1、2和3行向服务器发送“Hello,world”并得到回显。第4行是第一个保活探查，发生在两个小时以后(7200秒)。在第6行的TCP报文段能够发送之前，首先观察到的是一个ARP请求和一个ARP应答。
第6行的保活探查引出来自另一端的响应(第7行)。两个小时以后，在第7和8行发生了同样的分组交换过程。

如果能够观察到第6和第10行的保活探查中的所有字段，我们就会发现序号字段比下一个将要发送的序号字段小1(在本例中，当下一个为14时，它就是13)。

在放弃之前，我们仍可以观察到客户每隔75秒发送一个探查，一共发送了10次。从交互式脚本可以看到返回给客户进程的差错码被TCP转换为“连接超时”，这正是实际所发生的。
```

#### 另一端崩溃并重新启动
![]()
![]()

```
我们建立了连接，并从客户发送9个字节的数据到服务器(第1~3行)。两个小时之后，客户发送第1个保活探查，其响应是一个来自服务器的复位。
客户应用进程打印出“连接被对端复位”的差错。
```

#### 另一端不可达
![]()
![]()

```
我们建立了连接，并从客户发送9个字节的数据到服务器(第1~3行)。两个小时之后，客户发送第1个保活探查，其响应是一个来自服务器的复位。
客户应用进程打印出“连接被对端复位”的差错，这是有意义的。
```

## 优化(未完待续)
### 引言
![]()
### 建立连接优化
#### 复合连接
#### 旁路检测
### 维持连接优化
#### 混合自动重传请求(链路层)
#### 合包与动态评估
#### 读写多级超时间隔策略



